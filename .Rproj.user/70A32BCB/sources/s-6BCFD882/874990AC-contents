---
title: "KWTRP Proteomics workflow"
output: 
  flexdashboard::flex_dashboard:
    theme: yeti
    orientation: rows
    vertical_layout: scroll
   # social: menu
   #  source_code: embed
runtime: shiny
---
```{r setup, include=FALSE}

packagesLoad <-c("tidyverse","flexdashboard","RColorBrewer","gplots" , "GGally","FactoMineR" , "factoextra","gage",
                "gageData", "ggcorrplot" , "data.table", "limma" ,"edgeR" ,"org.Hs.eg.db" ,"pathview", "annotate",
               "AnnotationDbi" , "plotly" ,"UniProt.ws") # some more should auto load...
for(i in 1:length(packagesLoad)){
  if(require(packagesLoad[i], character.only = TRUE)==FALSE){
   # install.packages(packagesLoad[i]);
    #install bioconductor packages
    print(paste0("missing_", packagesLoad[i]))
    if(require(packagesLoad[i], character.only = TRUE)==FALSE) {
      #source("http://bioconductor.org/biocLite.R")
      #biocLite(packagesLoad[i],suppressUpdates=T,ask=F)
          print(paste0("missing_", packagesLoad[i]))

    }
    suppressPackageStartupMessages(library(packagesLoad[i], character.only = TRUE))
    }
  else { suppressPackageStartupMessages(library(packagesLoad[i],character.only = TRUE))}
}
suppressPackageStartupMessages(library("plotly"))

data("kegg.gs")
```


```{r}
source("processing_functions.R")
#source("helper.R")
load("Data/pathGenes")
load("Data/KEGGpathways")
load("uniprot_entrez")
load("uniprot_entrez2")
```


```{r}
#***************************
# READ IN THE DATA
#***************************
#' The function for reading in data.
#'
#' @param data from the shiny app 
#' @return a dataset
#' @export

dataInput <- reactive({
  infile <- input$proteomics_file
      if (is.null(infile)) {
      return(NULL)
      }
  dat <- data.frame(fread(infile$datapath, header = TRUE), row.names=1) ## --fread rewrite .csv .tibble
  dat <- data_orientation(dat) ## TO CHECK THE FUNCTION OF --data_orientation
  if(!is.null(dat$BATCH)){
    len <- dim(dat)[2]
    batch= dat$BATCH
    number_of_batches <- length(levels(as.factor(batch)))
    # Ignore the first two columns which correspond to the GROUP and BATCH variables 
    # (as per the currently expected data structure)
    new_dat <- dat[,3:len]
    y <- log2(t(as.matrix.data.frame(new_dat+1))) # log transform
    
    if(number_of_batches<2){
      y2 <- y
    }else{
      # Remove batch effect using linear models (LIMMA package functions)--removeBatchEffect
      y2 <- removeBatchEffect(y, batch) 
    }
    list(original=dat,raw=new_dat, data=y, corrected=y2, batch=batch,Group=dat$GROUP)
    }else{ 
      # if batch info is not there just return the data and the grouping variable separately
      len <- dim(dat)[2]
      # The first column correspond to the GROUP variable, the batch variable is not there
      y <- log2(t(as.matrix.data.frame(dat[,2:len]))+1)
      list(data=y, Group=dat$GROUP)
      }
  })
```



Sidebar {.sidebar data-width=300}
================================
### Upload Data
```{r}
fileInput("proteomics_file", "Choose a .csv File",
                  accept = c(
                    "text/csv",
                    "text/comma-separated-values,text/plain",
                    ".csv"))
radioButtons("data_type", "Type of data", choices = c("Proteomics", "RNAseq", "DNA Microarray"))

selectInput("organism", "Organism", choices = c("Human", "Mouse", "Plasmodium"))
```



QUALITY CHECK
====
Row
---
### Between Sample Correlation
```{r}
renderPlot({
  dat <- dataInput()[["data"]]
  corMatrix <- run_correlation(dat)
  ggcorrplot(corMatrix, hc.order = TRUE, type = "lower",
     outline.col = "white")
  }, width = 400)
```


### Between Sample Correlation
```{r}
# This part checks the correlation of the samples(observations/samples) thus the need to transpose the df
renderDataTable({
  dat <- dataInput()[["corrected"]]
  corMatrix <- run_correlation(dat) # Take note of why transpose
  }, options = list(scrollX=TRUE))

```

Row
---
### Batch effects check
```{r}
renderPlot({
  dat <- dataInput()
  if(length(dat)==6){
    original <-dataInput()[["data"]]
    batch_corrected <- dataInput()[["corrected"]]
    par(mfrow=c(2,1))
    boxplot(as.data.frame.matrix(original), main="ORIGINAL DATA")
    boxplot(as.data.frame.matrix(batch_corrected), main="BATCH CORRECTED")
  }else{
    
  }
})


## Not run: ------------------------------------
# # In server.R:
downloadData <- downloadHandler(
  filename = function() {
    paste("data-", Sys.Date(), '.csv', sep='')
  },
  content = function(file) {
    #dat <- dataInput()[["corrected"]]
    write.csv(dataInput()[["corrected"]], file)
  }
)

# # In ui.R:
downloadLink('downloadData', 'Download')
##







```


EXPLORATORY ANALYSIS
============
Row
---
### Heatmap 
```{r}
# Render the heatmaps
renderPlot({
  dat <- dataInput()[["corrected"]]
  # uses function from gplots package
  set.seed(354)
  heatmap.2(dat,
            col=rev(brewer.pal(9,"RdBu")), 
            #col = redgreen,
            trace = "none", 
            key = FALSE,
            Rowv = TRUE,
            labRow = FALSE)
  })
```

Row
---
### Principal Component Analysis (Samples)
```{r}

renderPlot({
  dat <- t(as.data.frame.matrix(dataInput()[["corrected"]]))
  hab <- dataInput()[["Group"]]

  res.pca <- prcomp(dat)
  fviz_pca_ind(res.pca, geom="point", habillage = hab,  shape.ind =
                 2,addEllipses=F)#+ 
#  labs(title=" Principal component analysis")#+
#  stat_ellipse(aes(color=factor(hab)))#+
#  scale_color_manual(values=c(  "#F8766D", "#00BFC4", "#7CAE00"))+
#  geom_point(aes(color=factor(new_dat$code2)))+
#  theme(legend.title=element_blank())
  
})
```


### Principal Component Analysis (Proteins)
```{r}

renderPlot({
  dat <- t(as.data.frame.matrix(dataInput()[["corrected"]]))
  res.pca <- prcomp(dat+1)
  fviz_pca_var(res.pca, geom="point", habillage = "none",  shape.ind=2,addEllipses=F)#+ 
#  labs(title=" Principal component analysis")#+
#  stat_ellipse(aes(color=factor(dat$Group)))+
#  scale_color_manual(values=c(  "#F8766D", "#00BFC4", "#7CAE00"))+
#  geom_point(aes(color=factor(new_dat$code2)))+
#  theme(legend.title=element_blank())
  
})

```


DIFFERENTIAL EXPRESSION {data-width=300}
======
```{r}
#**************************** 
#* DIFFERENTIAL EXPRESSION UI
#****************************
fillCol(height = 2500, width=1300, flex = c(NA,1),
        shinyUI(fluidPage(
          # INPUT PANEL
          inputPanel(
            selectInput("method", "DE Method:", 
                        choices = c("limma", "edgeR (Exact test)", "edgeR (Linear Fitting)", "deseq2")
                        ),
            radioButtons("normalization", "Normalization method:", 
                         choices = c("None","Log","VSN", "Quantile", "TMM", "RLE")
                         )
            ),
          
          # DISPLAY PANEL
          
          tabsetPanel(type = "tabs",
                      tabPanel("Table",
                               fluidRow(column(8,offset=1,tableOutput("DE_table")))
                               ),
                      tabPanel("Volcano plot",
                               fluidRow(column(8,offset=1,plotlyOutput("volcano2")))
                               ),
                      tabPanel("MDS plot",
                               fluidRow(column(8, offset = 1, plotOutput("MDS")))
                               )
                      )
          )))


#*********************************** 
#* SERVER SIDE
#***********************************
 raw_count_extract <- reactive({
    counts <- as.data.frame.matrix(t(dataInput()[["raw"]]))
    group <- dataInput()[["Group"]]
    dat <- make_DGEList(counts = counts, Grouping = group)
    dat[["normalized"]]
  })
  
batch_corrected_extract <- reactive({
    counts <- dataInput()[["corrected"]]
    group <- dataInput()[["Group"]]
    dat <- make_DGEList(counts = counts, Grouping = group)
    dat[["cds"]]
  })

MDS <- renderPlot({
    batch_corrected_unnormalized <- batch_corrected_extract()
    plotMDS(batch_corrected_unnormalized,
            main="Protein quantity differences: MDS", 
            labels=colnames(batch_corrected_unnormalized$counts), 
            col=c("blue", "red", "green")[batch_corrected_unnormalized$samples$group]
            )
  })
  

de_function <- reactive({
  if(input$data_type=="Proteomics"){
  dat <- raw_count_extract()
  cds <- calcNormFactors(dat, method="RLE")
  cds <- estimateCommonDisp(cds)
  cds <- estimateTagwiseDisp(cds)
  set.seed(354)
  et <- exactTest(cds, pair=levels(dat$samples$group))
  top <- topTags(et, n=nrow(cds$counts))$table
  #top_de <- filter(top,PValue<0.05)
  top_de <- top[(top$PValue <= 0.05),]
  list(de=data.frame(UNIPROT=rownames(top_de),top_de),full=top)
  }else if(input$data_type=="RNAseq"){
    dat <- raw_count_extract()
    cds <- calcNormFactors(dat, method="RLE")
    cds <- estimateCommonDisp(cds)
    cds <- estimateTagwiseDisp(cds)
    set.seed(354)
    et <- exactTest(cds, pair=levels(dat$samples$group))
    top <- topTags(et, n=nrow(cds$counts))$table
    #top_de <- filter(top,PValue<0.05)
    top_de <- top[(top$PValue <= 0.01),]
    top_de <- data.frame(GeneID=row.names(top_de),top_de)
    list(de=top_de, full=top)
  }

})

DE_table <- renderTable({
  de <- de_function()[["de"]]
  if(input$data_type=="Proteomics"){
    annotation_table <- as.data.frame( AnnotationDbi::select(org.Hs.eg.db, keys = as.character(de$UNIPROT), columns = c("UNIPROT","ENTREZID","SYMBOL","GENENAME"),keytype="UNIPROT"))
    tmp <- left_join(de, annotation_table)
  }else if(input$data_type=="RNAseq"){
    de
    
  }
  
  
    })
  
volcano <- renderPlot({
    dat <- raw_count_extract()
    cds <- calcNormFactors(dat, method="RLE")
    cds <- estimateCommonDisp(cds)
    cds <- estimateTagwiseDisp(cds)
    set.seed(354)
    et <- exactTest(cds, pair=levels(dat$samples$group))
    top <- topTags(et, n=nrow(cds$counts))$table
    de_table <- top[top$PValue<0.05,]
    de <- rownames(de_table)
    de_table$Protein_ID <- row.names(de_table)
    plot(x=top$logFC, 
     y=-log10(top$PValue), 
     pch=20, cex=.5, 
     ylab=" -Log False Discovery Rate (FDR)", 
     xlab="log Fold Change", 
     col=as.numeric(rownames(top) %in% de)+1,
     main="Differential Protein Expression Volcano Plot"
     )
    abline(v=c(-1, 1), col="royalblue")
    abline(h=c(-log(0.05, base=10)), col="royalblue")
  })



volcano2 <- renderPlotly({
  de_table <- de_function()[["full"]]
  de_table <- de_table[,c("PValue", "logFC")]
  de_table$group <- as.factor(ifelse(de_table$PValue<=0.05, "significant", "not-significant"))
  de_table$PValue <- -log10(de_table$PValue)
  
  plot_ly(de_table, x= ~logFC, y= ~PValue, color=~group)
  
})


```



ENRICHMENT ANALYSIS
====
```{r}

fillCol(height = 2500, width=1300, flex = c(NA,1),
        shinyUI(fluidPage(
          
          # INPUT PANEL
          inputPanel(
            #selectInput("pathways", label=h5("Choose a KEGG pathway"), as.list(KEGGpathways$names)),
            selectInput("annot_db", "Select Annotation Database", choices = c("GO", "KEGG", "DAVID")),
            uiOutput("DE_gene_list"),
            #uiOutput("filter_pathways"),
            uiOutput("pathways_gui_input")
           
            
            )#,
          
          # DISPLAY PANEL
          #fluidRow(column(8, offset=1, tableOutput("test")))#,
          #fluidRow(column(8, offset=1, plotOutput("volcano")))
          )))


# KEGG pathways represented in the data
represented_KEGG_pathways <- reactive({
  dat <- dataInput()[["corrected"]]
  proteins_in_data <- rownames(dat)
  tmp <- select(org.Hs.eg.db,keys = proteins_in_data, columns=c("UNIPROT","ENTREZID","SYMBOL","GENENAME"),keytype="UNIPROT")
  idx <-complete.cases(tmp)# remove those with NA values 
  tmp <- tmp[idx,]
  proteins <- tmp$ENTREZID
  tab <- lapply(pathGenes, function(x){sum(x %in% proteins)>=1})
  idx <- tab == TRUE
  tab <- tab[idx]
  KEGGpathways[as.character(names(tab)) %in% KEGGpathways$id,"names"]
  #KEGGpathways[names(tab) %in% KEGGpathways$id,"names"]
})


## Function for GO enrichment
# This function is suppose to do a GO enrichment using the GAGE algorithm
go_enrichment <- reactive({
  
  
  
  if(input$data_type== "RNAseq" || input$data_type=="DNA Microarray"){
    
    
  }else if(input$data_type=="Proteomics"){
    
  }
  
  
  
})









# Make a gui drop down showing represented pathways
pathways_gui_input <- renderUI({
    infile <- input$proteomics_file
  if(is.null(infile)){
    #print("FILE HAS NOT BEEN LOADED")
    }else{
  list_paths <- represented_KEGG_pathways()
  selectInput(inputId = "paths",label = "Present KEGG pathways", choices = list_paths)
  }
})


#Function to obtain genes in the user chosen KEGG pathway
genes_in_selected_pathway <-reactive({
  pathway <- input$paths
  idx <- which(KEGGpathways$names==pathway)
  pathway_id <- KEGGpathways$id[idx]
  tmp <- pathGenes[[pathway_id]]
  tmp
  })

# Table annotating those genes
pathway_annotation_table <- reactive({
  my_keys = genes_in_selected_pathway()
  select(org.Hs.eg.db,keys = as.character(my_keys),columns=c("UNIPROT","ENTREZID","SYMBOL","GENENAME"),keytype="ENTREZID")
  #my_keys
})

pathway_genes_represented_in_data <- reactive({
      dat <- dataInput()[["corrected"]]
      proteins <- data.frame(UNIPROT=rownames(dat))
      annotation_table <- pathway_annotation_table()
      table1 <- inner_join(proteins,annotation_table)
      de_data <- de_function()[["de"]]
      inner_join(table1, de_data)
})

## UI select input with list of differentially expressed genes
DE_gene_list <- renderUI({
  infile <- input$proteomics_file
  if(is.null(infile)){
    #print("FILE HAS NOT BEEN LOADED")
  }else{
  de_table <- de_function()[["de"]]
  de <- de_table[(de_table$PValue <= 0.05),]
  annotation_table <- select(org.Hs.eg.db, keys = as.character(de$UNIPROT), columns = c("UNIPROT","ENTREZID","SYMBOL","GENENAME"),keytype="UNIPROT" )
  tmp <- inner_join(de, annotation_table)
  selectInput(inputId = "de_in", label = "Choose differentially expressed gene", choices = tmp$GENENAME )
  }
  
})


## Action Button to filter pathways the DE gene is involved
filter_pathways <- renderUI({
  de_list <- input$DE_gene_list
  if(is.null(de_list)){
    #print("FILE HAS NOT BEEN LOADED")
  }
  else{
    actionButton(inputId = "filter_paths", label = "Filter Pathways involved")
  }
})


### THIS IS ONLY FOR TESTING IF OUTPUT WORKS
test <- renderTable({
  #dat <- de_function()
  #gage_analysis()
  #represented_KEGG_pathways()
  #uniprot_to_entrez()
  #genes_in_selected_pathway()
  #pathway_annotation_table()
  #pathway_genes_represented_in_data()
  dataInput()[["original"]]
})







# uniprot_to_entrez <- reactive({
#     dat <- dataInput()[["corrected"]]
#     proteins <- rownames(dat)
#     idx <-  uniprot_entrez2$UNIPROTKB  %in% proteins
#     represented_proteins <- uniprot_entrez2[idx,]
#     represented_proteins
#  })
# 
# gage_analysis <- reactive({
#   dat <- t(dataInput()[["corrected"]])
#   grouping <- dataInput()[["Group"]]
#   ref.idx <- which(grouping==levels(grouping)[1])
#   samp.idx <- which(grouping!=levels(grouping)[1])
#   cnts.kegg.p <- gage(dat, gsets = kegg.gs, ref = ref.idx,
#                      samp = samp.idx, compare ="unpaired")
#   cnts.kegg.p$greater
#   #sel <- cnts.kegg.p$greater[, "q.val"] < 0.1
# 
# })







```

Testbed
====
```{r}







```






