---
title: "CAR Models"
author: "KM Wambui/E Musenge/Zvifadzo Matsena"
subtitle: using Zimbabwe DHS data
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment=NA, tidy = T)
## load the packages needed for this module
library(R2WinBUGS) ## Help in connecting R to WinBugs
library(tidyverse) ## package for data manipulation
library(rgeos) ## Geomegry Engine- Open Source (GEOS)
library(maptools) ##  R package with useful map tools
library(broom) ## for converting a map to a data frame
library(rgdal) ## Geospatial Data Analysis Library (GDAL)"
library(rgeos) # # "Geomegry Engine- Open Source (GEOS)" -- check your shape file
library(mcmc)
library(spdep)
library(data.table)
library(haven) ## read in stata files
library("PerformanceAnalytics") ## EDA
library(INLA) ## inla

## remove the data in the environment
rm(list = ls())
```

# Shape files in R

## Reading and exporting? the shape file

```{r}
zim_shp <- maptools::readShapePoly("zim_shape/ZWE_adm2.shp",
                                        IDvar="ID_2")
plot(zim_shp, border="red", axes=TRUE, las=1 )
```


## What R is reccommending

```{r}
zim_OGR <-  rgdal::readOGR("zim_shape/ZWE_adm2.shp")
plot(zim_OGR, border="blue", axes=TRUE, las=1)
```

We need to check our shape file to see if the spatial geometry is valid and the `gIsValid` function looks at each polygon, and makes sure it doesnâ€™t break any topological rules. Ideally, all of the geometry is valid and the total number of polygons that fail the validity tests is 0.

```{r}
zim_valid <- data.table(valid=gIsValid(zim_OGR,byid=TRUE))
sum(zim_valid$valid==F)
```


## Export SPlus map format
Splus is the map file to use in Bayesian inference Using Gibbs Sampling (BUGS) softwares mostly OpenBugs or WinBUGS. `sp2WB` is the function exports an sp SpatialPolygons object into a S-Plus map format to be imported (__covered earlier__). 

```{r}
## saving the Ssplus map in zim_shp folder
maptools::sp2WB(map =as(zim_shp, "SpatialPolygons"),
                filename="zim_shape/zim_spus" )
```


## The adjacency matrix for the map
Remember the importance of CAR models , to adjust for the neighbouring effect. We extract the matrix to represent the structure of the neighbors. Can be done on OpenBUGS or in R (here we use the OpenBUGs extract)

```{r}
## create the zim_nb map using poly2nb function
zim_nb<- spdep::poly2nb(zim_shp)
num <- sapply(zim_nb, length)
adj <- unlist(zim_nb)
sumNumNeigh <- length(unlist(zim_nb))

## neighbouring iformation from BUGS --> in the code file its included further down
##modelling 
num = c(5, 7, 8, 4, 4, 8, 5, 3, 4, 7, 
        5, 5, 8, 6, 4, 8, 8, 8, 7, 4, 
        7, 5, 8, 7, 6, 6, 5, 10, 3, 6, 
        7, 7, 7, 6, 6, 8, 7, 4, 5, 8, 
        4, 7, 6, 4, 8, 3, 6, 6, 9, 2, 
        6, 6, 7, 6, 6, 6, 6, 5, 6, 5)
adj = c(
  52, 51, 47, 45, 40, 
  31, 26, 23, 19, 18, 13, 10, 
  35, 32, 25, 17, 7, 6, 5, 4, 
  32, 7, 5, 3, 
  33, 32, 4, 3, 
  25, 22, 21, 19, 9, 8, 7, 3, 
  25, 8, 6, 4, 3, 
  9, 7, 6, 
  22, 20, 8, 6, 
  21, 18, 16, 14, 13, 11, 2, 
  16, 14, 13, 12, 10, 
  31, 30, 27, 13, 11, 
  31, 18, 16, 14, 12, 11, 10, 2, 
  24, 16, 15, 13, 11, 10, 
  24, 20, 16, 14, 
  24, 21, 18, 15, 14, 13, 11, 10, 
  53, 35, 28, 26, 25, 23, 19, 3, 
  24, 23, 21, 19, 16, 13, 10, 2, 
  25, 23, 21, 18, 17, 6, 2, 
  24, 22, 15, 9, 
  24, 22, 19, 18, 16, 10, 6, 
  24, 21, 20, 9, 6, 
  31, 28, 26, 25, 19, 18, 17, 2, 
  22, 21, 20, 18, 16, 15, 14, 
  23, 19, 17, 7, 6, 3, 
  31, 30, 28, 23, 17, 2, 
  54, 30, 29, 28, 12, 
  57, 55, 54, 53, 31, 30, 27, 26, 23, 17, 
  54, 39, 27, 
  54, 31, 28, 27, 26, 12, 
  30, 28, 26, 23, 13, 12, 2, 
  38, 36, 35, 33, 5, 4, 3, 
  46, 38, 37, 36, 34, 32, 5, 
  60, 59, 58, 37, 36, 33, 
  53, 38, 36, 32, 17, 3, 
  59, 53, 38, 37, 35, 34, 33, 32, 
  60, 58, 48, 46, 36, 34, 33, 
  36, 35, 33, 32, 
  55, 54, 42, 41, 29, 
  57, 56, 52, 49, 45, 43, 42, 1, 
  47, 44, 42, 39, 
  55, 45, 44, 43, 41, 40, 39, 
  57, 56, 55, 49, 42, 40, 
  47, 45, 42, 41, 
  52, 51, 49, 47, 44, 42, 40, 1, 
  48, 37, 33, 
  51, 50, 45, 44, 41, 1, 
  58, 52, 51, 49, 46, 37, 
  60, 59, 58, 56, 52, 48, 45, 43, 40, 
  51, 47, 
  52, 50, 48, 47, 45, 1, 
  51, 49, 48, 45, 40, 1, 
  59, 57, 56, 36, 35, 28, 17, 
  55, 39, 30, 29, 28, 27, 
  57, 54, 43, 42, 39, 28, 
  59, 57, 53, 49, 43, 40, 
  56, 55, 53, 43, 40, 28, 
  60, 49, 48, 37, 34, 
  60, 56, 53, 49, 36, 34, 
  59, 58, 49, 37, 34)
sumNumNeigh = 360
```


# Zimbabwe HAZ (Stunting) CAR Model
## Load the data

```{r}
zim_child_data <- haven::read_dta("data/Data2.dta")
#dplyr::glimpse(zim_child_data , width = 5)
```

## Explolatory Data Analysis

```{r}
## EDA
eda_data <- zim_child_data %>% 
  select(Stunting, Employed, b19, Education, b4 , v025, BMI)
PerformanceAnalytics::chart.Correlation(eda_data, histogram=TRUE, pch=19)
```


## Linear regression model

```{r}
## Define the formula of the model
form_fit <- Stunting ~ Employed +b19  +  as.factor(Education) + b4+ v025+ BMI

## fit the model
lin_mod <- glm(form_fit, 
               data=zim_child_data, 
               family=gaussian(link="identity"))
```

Extract the summary statistics from the model. What do the estimates mean?

```{r}
summary(lin_mod)$coefficient
AIC(lin_mod)  # AIC => 17272
BIC(lin_mod)  # BIC => 17333
```


## Check for the assumptions
We focus on the  Residuals vs Fitted values and the  Normal Q-Q. This will inform our decision on whether the outcome has met the assumptions to be used in further spatial models


```{r}
par(mfrow = c(2,2)) # display a unique layout for all graphs
plot(lin_mod)
par(mfrow = c(1,1)) 
```

\newpage

# CAR model in BUGS 

## Select the variables of interest

What approaches can you use to select the variables of interest. 
- Stepwise regression [1^]
- Regulization methods [2^]

[1^]: http://web.nchu.edu.tw/~numerical/course1012/ra/Applied_Regression_Analysis_A_Research_Tool.pdf
[2^]: https://web.stanford.edu/~hastie/Papers/B67.2%20%282005%29%20301-320%20Zou%20&%20Hastie.pdf


Here we have already selected the variables to use  and we use complete case data. 

```{r}
zim_child_model <- zim_child_data %>%  
  select(id_2 , name_1 , name_2 , Stunting, Employed, b19, Education, b4, v025, BMI)
zim_child_model <- zim_child_model[complete.cases(zim_child_model),]
glimpse(zim_child_model)
```


Check whether the ID_2 on the shape file corresponds to what you have in your data

```{r}
table(zim_shp@data$ID_2 %in% zim_child_model$ID_2)
table(zim_shp@data$NAME_2 %in% zim_child_model$name_1)
```


## Creating a data set to use in BUGS
We create a list in R with all the variables of interest. 

```{r}
data_model <- list("N"=length(zim_child_model$Stunting) , 
                   "adj"=adj,"num"=num ,
                  "sumNumNeigh" =sumNumNeigh,
                  "Stunting" =zim_child_model$Stunting,
                  "Employed"=as.numeric(zim_child_model$Employed) ,
                  "Education"=zim_child_model$Education,
                  "b4" = as.numeric(zim_child_model$b4),
                  "v025" = as.numeric(zim_child_model$v025),
                 "BMI" = as.numeric(zim_child_model$BMI),
                  "b19"=as.numeric(zim_child_model$b19), 
                  "id_2"=zim_child_model$id_2)
names(data_model)
```


## Our BUGS code

The code is saved as `bugs_models.txt` in our working directory and contains

```{stan output.var='priors', eval = FALSE, tidy = FALSE}
model {
#Likelihood
for( i in 1 : N ) {
			Stunting[i] ~ dnorm(mu[i], tau)  
			mu[i]<-beta[1]+
			  beta[2]*equals(Education[i],1)+
			  beta[3]*equals(Education[i],2)+
			  beta[4]*equals(b4[i],2)+
			  beta[5]*equals(v025[i],2)+  
			  beta[6]*equals(Employed[i],1)+
			beta[7]*BMI[i]+beta[8]*b19[i]+
			   u[id_2[i]] + Phi[id_2[i]]
}
#Priors
for (i in 1:8)
{
 beta[i]~dnorm(0.0, 0.001)
}                           
###### Unstructured groups
for (k in 1:60) 
 {
 u[k] ~ dnorm(0,tauu)
}
###### CAR prior distribution for structured random effects: 
# Bivariate CAR Prior for Phi -- Spatial Main Effects
Phi[1:60] ~ car.normal(adj[], weights[], num[], tau)     # num specifies no. of neighbors 
for(i in 1:sumNumNeigh){weights[i] <- 1}  	
###### Hyperpriors
tauu ~ dgamma(0.01, 0.01)
tau  ~ dgamma(0.5, 0.0005)
#tauVal <- loggam(tau)
tauh  ~ dgamma(0.5, 0.0005)
}
```


## Defining the important parameters 

```{r}
### 
####defining the initials
# Initial Inits
inits_Vals <-  function(){
  list(beta = c(0,0,0,0,0,0,0,0))
}

## parameters we want to monitor in R
params <- c("beta" , "Phi")
```


## Running the CAR model from R 

Here we use the `R2OpenBUGS` package using the `bugs` function to push the model to OpenBUGS.

- `data` is the data we defined to use
- `model.file="bugs_models.txt"`  is the file in our working directory with the BUGS code
-`inits_Vals1` = are the initial points where the different parameters in our model start for the MCMC. Mostly we can use the mean of the variable but here we use 0 for only the beta parameters. (Figure out how to initialize for the other parameters)

- `parameters.to.save` - parameters we want to save from the model. here we save the regression `beta` coefficients and the location (`id_2`) mean estimate of HAZ

- `n.chains` - specifying the number of markov chain. (Figure out how to fit for 2 chains)

- `n.iter=10000` - specifying the number of iterations for our MCMC. We have specified 10000 (reduce to 1000 for this exercise)

- `n.burnin=2000` - the values to burn in , can be guided by the diagnostic plots. We have burned in 2000 (reduce to 200 for this exercise)

- `n.thin=10` - the values to thin to reduce autocorrelation

```{r , eval=FALSE}
model_bugs <-  R2OpenBUGS::bugs(data = data_model,
                                 model.file="bugs_models.txt",
                                 inits=inits_Vals,
                                 parameters.to.save = params,
                                 n.chains=1,n.iter=10000,
                                 n.burnin=2000,n.thin=10,codaPkg=T,digits = 5,
                                 debug = F,DIC=TRUE,clearWD = TRUE,
                                ## uncomment below for WinBUGs
                                ##bugs.dir = "C:/Program Files (x86)/WinBUGS14/",
                                 working.directory = file.path(paste0(getwd(),"codas")))
```


Since I had run the model above , I read in the saved coda or ourput

```{r ,  results='hide', message=FALSE, warning=FALSE}
coda_res   <- R2OpenBUGS::read.bugs("codas/CODAchain1.txt")
```

## Get the posterior means of the model parameters


```{r}
##
summary_model <- summary(coda_res)
summary_model$statistics
```


## Model diagnostics

Here we perform model diagnostics using the code below. It generates posterior estimates plots and other diagnostic plots

```{r, eval=FALSE}
## diagnostics
dir.create("results/str_unstru/figures", recursive = T)
mcmcplots::mcmcplot(coda_res, 
                    dir=file.path(getwd(),"results/str_unstru/figures") ,
                    regex = "beta|Phi")
```


## Ploting our estimated to a map

We extract the spatial estimates from the model using `summary_model$statistics`  and merge with the shape file and plot

```{r ,message=FALSE, warning=FALSE, tidy=FALSE}
## add the mean to a plot
df_model <- as.data.frame(summary_model$statistics) %>% 
  tibble::rownames_to_column("id_var")


## select spatial parameters only
df_model_spat <- df_model %>% 
  ##remain with Phi var
  filter(grepl("Phi",id_var)) %>% 
  mutate(ID_2=gsub("Phi\\[","",id_var),
         ID_2=gsub("\\]","",ID_2))
glimpse(df_model_spat)
```


```{r, message=FALSE, warning=FALSE  , tidy=FALSE}
## plot the mean estimates on the map
zim_shp@data <- zim_shp@data  
zim_shp_df <- broom::tidy(zim_shp, region = "ID_2")
zim_shp_df <- zim_shp_df %>% 
  left_join(df_model_spat, by=c("id"="ID_2"))

glimpse(zim_shp_df)
p1 <- ggplot() + 
  geom_polygon(data = zim_shp_df, aes(x = long, y = lat,
                                  group = group,
                                  fill = Mean), colour = "white") + theme_void()
p1
```


# CAR model in INLA 

It uses the Integrated Nested Laplace Approximation, a deterministic Bayesian method [^1] and a very nice book here by Marta Blangiardo [^2].

[^1]: http://www.r-inla.org/download
[^2]: http://www.r-inla.org/books

## Normal linear model in INLA
In the formula below  1 means that the model includes the intercept and

```{r , tidy=FALSE}
form_fit <-  Stunting ~1+ Employed +b19  + 
  as.factor(Education) + b4+ v025+ BMI


model_linear <- inla(form_fit,
                     family="gaussian",
                     data=zim_child_model,
                    control.compute=list(dic=TRUE, waic=TRUE))
```


## Extracting the model summaries

Here we compare our glm model with the linear model from INLA, are they similar?


```{r}
summary(model_linear)
summary(lin_mod)
```

Extracting the summary of the fixed effects

```{r}
round(model_linear$summary.fixed[,1:5],3)
```


```{r}
par(mfrow = c(2,2)) # display a unique layout for all graphs
## Posterior density plot for the intercepts
plot(model_linear$marginals.fixed[[1]],
     type="l",
     main="",
     ylab="",
     xlab=expression(beta[0]))
plot(model_linear$marginals.fixed[[2]],
     type="l",
     main="",
     ylab="",
     xlab=expression(beta[1]))
par(mfrow = c(1,1))
```


## Spatial Model in INLA

First we convert our neighbour map to an inla intergrated map , a map that INLA can use to evaluate its model

```{r}
nb2INLA("zim_shape/zim_inla.graph", zim_nb)
zim_adj <- paste(getwd(),"/zim_shape/zim_inla.graph", sep="")
```

Then we generate the adjacency matrix  for the ZIM example: in the plot below rows and columns identify areas; squares identify neighbors 


```{r}
H <- inla.read.graph(filename="zim_shape/zim_inla.graph")
image(inla.graph2matrix(H),xlab="",ylab="")
```

## Fitting CAR in INLA

After having defined our neighbourhood structure, then we need to specify the formula for the model, through

```{r}
formula_inla <- Stunting ~ 1 + as.factor(Employed) +
  b19  + as.factor(Education) + b4+ v025+ BMI+
  
  ##our CAR specification
  f(id_2, model="bym",graph=zim_adj, scale.model=TRUE,
    ## spefiying the priors for the unstri and str 
                     hyper=list(prec.unstruct=list(prior="loggamma",param=c(1,0.001)), 
                                prec.spatial=list(prior="loggamma",param=c(1,0.001))))

```


where `id_2` represents the identifiers for the locations and through the graph option we include the name of the object containing the neighborhood structure. Note that with f(ID, model="bym",...) R-INLA parameterizes 

$${{\xi }_{i}}={{u}_{i}}+{{\upsilon }_{i}}$$


By default, minimally informative priors are specified on the log of the unstructured effect precision $\log \left( {{\tau }_{\upsilon }} \right)\sim \log Gamma\left( 1,0.0005 \right)$ and the log of the structured  effect precision $\log \left( {{u}_{\upsilon }} \right)\sim \log Gamma\left( 1,0.0005 \right)$ 

```{r , tidy=FALSE}
model_inla <- inla(formula_inla,family="gaussian",
                     data=zim_child_model,
                     control.compute=list(dic=TRUE))
 

```


```{r}
summary(model_inla) #inla --> 17218.91(15.09) ##linear model--> 17272.83(9.444)
```


## Summary of the fixed effect

```{r}
round(model_inla$summary.fixed,3)
```


## Summary of the random effects


```{r}
round(head(model_inla$summary.random$id_2),3)
```


## Plotting the estimates on map

FOr this excercise, we plot the probaility of having high HAZ in ZIM to compare with out BUGs model. FIrst extract the marginals of the random effects


```{r}
csi <- model_inla$marginals.random$id_2[1:60]
```

Then create the  posterior probablity using `inla.pmarginal` function. 

```{r}
# *** Code for posterior probablity
a <- 0
prob_csi <- lapply(csi, function(x) {1 - inla.pmarginal(a, x)})
## for each location estimate the probability in continous
cont_prob_cs1 <- data.frame(maps_cont_prob_csi=unlist(prob_csi)) %>% 
  tibble::rownames_to_column("ID_2") %>% 
  mutate(ID_2=gsub("index.","",ID_2))

maps_cont_prob_csi <- cont_prob_cs1
```


Or create catoroes if you wish

```{r , eval=F}
# for each location estimate the probability in groups
prob_csi_cutoff <- c(0,0.2,0.4,0.6,0.8,1) ## can change accordingly
cat_prob_csi <- cut(unlist(prob_csi),
                    breaks=prob_csi_cutoff, 
                    include.lowest=TRUE)


maps_cat_prob_csi <- data.frame(ID_2=unique(zim_child_model$id_2), ## check whether it joins well
                                cat_prob_csi=cat_prob_csi)
maps_cat_prob_csi$ID_2 <- as.character(maps_cat_prob_csi$ID_2)
```


Eventually, we jooin our posterior probabilities to the data

```{r , tidy=F ,, message=FALSE, warning=FALSE }
zim_shp_df <- broom::tidy(zim_shp, region = "ID_2")
zim_shp_df <- zim_shp_df %>% 
 # left_join(maps_cat_prob_csi, by=c("id"="ID_2")) %>% 
  left_join(maps_cont_prob_csi, by=c("id"="ID_2"))

glimpse(zim_shp_df)
```


We have our plot, is it similar


```{r}
p2 <- ggplot() + 
  geom_polygon(data = zim_shp_df, aes(x = long, y = lat,
                                      group = group,
                                      fill = maps_cont_prob_csi), 
               colour = "white") + theme_void() +
  ggtitle("RINLA Fit") + labs(fill = "P of  high HAZ") +
  scale_fill_continuous(high = "#fff7ec", low = "#7F0000")
p2
```


\newpage

```{r , echo=FALSE}
p1 <- p1 + scale_fill_continuous(high = "#fff7ec", low = "#7F0000") +
  ggtitle("Open Bugs Fit") + labs(fill = "Average HAZ")
gridExtra::grid.arrange(p1,p2, nrow=2, hei ) 
```

